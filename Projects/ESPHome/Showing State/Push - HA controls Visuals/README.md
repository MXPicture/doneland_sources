<img src="/assets/images/convert.jpg" width="80%" height="80%" />
 
# Push - Home Assistant Controls Visuals

> Creating A Central Automation Script In Home Assistant To Manage Visuals In Dashboards And Remote Controls


In this scenario, *Home Asisstant* is centrally updating all **Visuals** in any of your devices when the state of an **Effector** changes.

## Overview

A central automation script to update **Visuals** has many advantages:

* **Safe:**    
  Devices do not require API access, so if a device is hacked, it provides a limited attack surface
* **Clear:**   
  There is just **one** place that manages **all** relationships between device states and **Visuals**. This makes it easy to maintain, and you don't need to roll out new device firmware just because you renamed a device or want to re-organize the devices a particular remote control manages.

### Tasks

The central automation script is responsible for managing **two** tasks:

* **Device State:**    
  When the **state** of a device (that you want to monitor via **Visuals**) **changes**, it needs to update the state of all **Visuals** that represent this device
* **Initialize State:**   
  A device with a **Visual** may turn on and off at any time, independent from the **Effectors**. The automation script must detect when a device with a **Visual** becomes available so it can immediately **initialize** its **Visuals**. Else, the **Visuals** would be updated only on the next *device state change*, and until this happens, the **Visuals** would not show the correct device state.
  

## Central Automation Script
*Home Assistant* maintains a central automation script called `/config/automations.yaml`. 

The content of this script is not directly accessible via the *Home Assistant UI*. You would need to install a text editor add-on in *Home Assistant* such as *File Editor* or *Studio Code Server*, but this effort is not needed.

### Automations
*Automations* enable you to *teach Home Assistant* to perform certain tasks **automatically**. You can, for example, establish **relationships** between separate devices: if sensor *A* is above temperature *B*, turn on device *C* - a fan for example.

Likewise, when a certain button on a device is pressed, you may want *Home Assistant* to toggle the state of a plug somewhere else, effectively turning the button in a **remote control**, and **pairing** it to a plug.

### Accessing Automations
All automations you have ever defined are listed in the *Home Assistant User Interface* via **Settings**/**Automations & scenes**.

Initially, this list is empty, and by clicking **CREATE AUTOMATION**, you add any number of automation tasks.

### How it works

* `automations.yaml`:     
  *Home Assistant* maintains a hidden file: `/config/automations.yaml`. You can view and edit it with special tools, but it is better to let *Home Assistant* transparently handle this file.
* **Purpose:**     
  *Home Assistant* reads `automations.yaml` at startup (and whenever you edit the file), and updates its own task lists accordingly.
* **Automation:**     
  When you create a new automation in the user interface, *Home Assistant* adds code to `automations.yaml`. By adding a new automation, you are in fact **indirectly** editing `automations.yaml`, but the user interface protects you from mishaps that could damage other automations in this file.
* **Wizard:**     
  **CREATE AUTOMATION** invokes a wizard that helps you compose a new automation task: by answering simple questions and selecting devices from dropdown lists, *Home Assistant* writes the automation script for you in the background. 
* **List of Automations:**     
  All your automations are listed in **Settings**/**Automations & scenes** where you can click them to re-open the wizard to view the settings and also apply changes when needed. 
* **Advanced Editing and Refining:**     
  The three-dot menu in the upper right corner of an **opened** automation, lets you *disable*, permanently *delete*, or even view its **source code**:   
    
    Clicking *Edit in YAML* displays the actual code that the wizard generated, and if you feel comfortable, you could directly program your automations and bypass the wizard and the UI.


### Example

This code was automatically generated by the wizard:

````

alias: Toggle Plug T34-19
description: When push button is pressed, toggle state of plug
mode: single
triggers:
  - type: turned_on
    device_id: d93e239b5f04ccdd3b671c70303a45ab
    entity_id: 9490a273345f25f05d90e72c42bb2f20
    domain: binary_sensor
    trigger: device
conditions: []
actions:
  - type: toggle
    device_id: 05a1d541fac7c7fc3d6127e1af0b0116
    entity_id: 8db7a92b4ce6e0168ccb4b3e7f9908ea
    domain: switch
````

It toggles a plug when a button on a device is pressed. 

This code was never meant to be read by humans: while it works just fine, it is hardly readable because it references the devices by their internal id numbers.

If you are fine with the *wizard* and its *UI*, you never need to look at this code, so its structure is not important.

If however you'd like to dive deeper and take more control by editing and adjusting the code directly, it is best to rephrase the code, i.e. with the help of *ChatGPT*, to make it easier to understand and maintain.

Here is the same automation rephrased, using clear-text *Entity IDs* to reference the devices involved:

````
alias: Control Fan
description: Toggle the fan when the push button is pressed
mode: single
trigger:
  - platform: state
    entity_id: binary_sensor.push_button_pushbutton1
    to: "on"
action:
  - service: switch.toggle
    target:
      entity_id: switch.plug_t34_38_switch_1
````